
add_vals = [
    0x3345, 0x2b58, 0x0b3f, 0x0807, 0x2dc0, 0x0871, 0x42a2, 0x1f2b,
    0x0871, 0x2cc0, 0x1520, 0x34d5, 0x1c6f, 0x1c80, 0x20fc, 0x3ad1,
    0x2e17, 0x32de, 0x056b, 0x61da, 0x02e2, 0x61f1, 0x24da, 0x0598,
    0x080d, 0x2a9b, 0x501a, 0x3ac3, 0x13e6, 0x5d60, 0x1c6c, 0x4856,
    0x2c87, 0x304d, 0x05d1, 0x61d4, 0x02e2, 0x1ad6, 0x06ca, 0x0d5e,
    0x38cc, 0x4d20, 0x3719, 0x1f42, 0x0522, 0x0200, 0x35e4, 0x3a9f,
    0x0306, 0x0200, 0x0e94, 0x001e, 0x4d9b, 0x524f, 0x18cf, 0x0280,
    0x0f6e, 0x0f6e, 0x3556
]

xor_vals =  [
    0x2b, 0x22, 0x6f, 0x91, 0x6a, 0x57, 0x9a, 0x8b,
    0x57, 0x54, 0xfc, 0x23, 0xd5, 0xe8, 0xb8, 0x43,
    0xb7, 0xec, 0x53, 0x04, 0x0c, 0xf1, 0x0e, 0xb8,
    0xbb, 0xd1, 0xd6, 0xa1, 0xde, 0xfc, 0xf6, 0x4a,
    0x1f, 0x83, 0xb5, 0x1e, 0x0c, 0x04, 0x52, 0xde,
    0xdc, 0x10, 0xbb, 0x9e, 0xee, 0xd4, 0x02, 0x55,
    0x58, 0xd4, 0xb0, 0x08, 0xad, 0x6d, 0xdb, 0x1a,
    0x2a, 0x2a, 0x76
]
def do_xor(a, b):
    ret = swap_arr[a]
    for i in range(a+1, b):
        # print(hex(swap_arr[i]))
        ret ^= swap_arr[i]
    return ret 

def get_sbox():
    sbox_data = open('./sbox.bin', 'rb').read() 
    sbox_seg = [sbox_data[i:i+8] for i in range(0,len(sbox_data),8)]
    sbox = []
    for i in sbox_seg:
        temp = int.from_bytes(i,byteorder='little')
        sbox.append(temp)
    return sbox 

sbox = get_sbox()
swap_arr = [i for i in range(256)] 
solution_arr = [68]


def check_block(correct_sum_val, correct_xor_val, cur_pos, test_val):
    '''
    Check that this block is valid 
    pass in the correct_xor_val, correct_add_val
    this is essentially the stuff inside the for loop 
    '''
    # print(arr)
    # print(arr[cur_pos])
    # input("double checking arr")
    x_a = sbox[ solution_arr[ cur_pos ] ]
    x_b = sbox[ test_val ]
    y_a = sbox[x_a]
    y_b = sbox[x_b]
    s_a = swap_arr[x_b]
    s_b = swap_arr[y_a]
    a = s_a
    b = s_b
    # print(a, b, cur_pos)
    # print( x_a, y_a, s_b )
    # input()

    temp = None
    test_flag = False
    # if b >= a:
    #     temp = b
    #     b = a
    #     a = temp
    #     test_flag = True
    # assert b <= a

    # if test_flag == False:
    # sum_val = sum(swap_arr[b:a+1])
    # xor_val = do_xor(b, a+1)     

    temp3 = min(x_b, y_a)
    temp4 = max(x_b, y_a)
    print("temp3 and 4 vals: ", hex(temp3), hex(temp4))
    sum_val = sum(swap_arr[temp3:temp4+1])
    xor_val = do_xor(temp3, temp4+1)      
    
    # else:
    #     sum_val = 0
    #     xor_val = 0
    print("test_val: ", hex(test_val))
    print(hex(b),hex(a), hex(y_a), hex(x_b))
    print(hex(sum_val), hex(correct_sum_val))
    print(hex(xor_val), hex(correct_xor_val))                    
    print("--------------------------------")
    ret_val = [None, None, None, None]
    ret_val[0] = (sum_val == correct_sum_val) and (xor_val == correct_xor_val)
    ret_val[1] = x_b
    ret_val[2] = y_a
    ret_val[3] = test_flag
    if test_val == 0x47:
        print([hex(i) for i in swap_arr])
    return ret_val

    
def get_original():
    '''
    Get the original input 
    '''

    # need to break this apart 
    # add some check 
    # we already know 0 and 1 values
    # print(sbox[43], sbox[167])

    for i in range(len(add_vals)):
        flag = False
        x_b = None 
        y_a = None
        print("solution arr char: ", chr(solution_arr[i]))
        for j in range(32, 128):
        # for j in range(256):
            ret = check_block(add_vals[i], xor_vals[i], i, j)
            ok = ret[0]
            x_b = ret[1]
            y_a = ret[2]
            # if chr(j) == 'H':
                # continue
            if ok:
                solution_arr.append(j)
                flag = True
                print(ret[3])
                input("Found!")
                break
        if flag == False:
            input("Failed! something went awry")
        else: 
            print([chr(i) for i in solution_arr])
            # input(chr(solution_arr[-1] ))
            
            # correct_xor_val, correct_sum_val, cur_pos, check_val): 
            # swap 1
            # first iteration looks ok, but swap might be wrong 
            # yea not sure what i am missing but could be something to do with the swap?
            
        temp = swap_arr[x_b]
        swap_arr[x_b] = swap_arr[y_a]                             
        swap_arr[y_a] = temp 
        print(hex(x_b), hex(y_a))
        print([hex(i) for i in swap_arr])
        print(solution_arr[-1])
        input() 
        
def main():
    # cur_sol = 'DH{Go!' + chr(0x33) + 'A' * 53
    # cur_sol = b'DH{Go!' + b'\xc2\x47' + b'A' * 52
    # G works, so there is some modulo arithmetic happening
    # 0xae -> 0x47; why 
    cur_sol = b'DH{Go!' + b'G0g' + b'A' * 51
    cur_sol = b'DH{Go!G0!G' + b'A' * 50
    # assert len(cur_sol) == 60
    f = open('./payload', 'wb')
    f.write(cur_sol)
    f.close() 
    assert len(add_vals) == len(xor_vals)
    get_original() 

if __name__ == '__main__':
    # a = [
    #     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    #     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    #     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    #     0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    #     0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
    #     0x28, 0x29, 0x2a, 0xa7, 0x2c, 0x2d, 0x2e, 0x2f,
    #     0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    #     0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    #     0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
    #     0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    #     0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
    #     0x58, 0x59, 0xae, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    #     0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
    #     0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    #     0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
    #     0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    #     0x80, 0x81, 0x90, 0x83, 0x84, 0x85, 0x86, 0x87,
    #     0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0xd1, 0x8f,
    #     0x82, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    #     0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
    #     0xa0, 0xa1, 0xa2, 0xb4, 0xa4, 0xa5, 0xa6, 0x2b,
    #     0xa3, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0x5a, 0xaf,
    #     0xb0, 0xb1, 0xb2, 0xb3, 0xa8, 0xb5, 0xb6, 0xb7,
    #     0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
    #     0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
    #     0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
    #     0xd0, 0x8e, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
    #     0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
    #     0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7,
    #     0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
    #     0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
    #     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,
    # ]
    # # a = [hex(i) for i in a]
    # b = ['0x0', '0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7', '0x8', '0x9', '0xa', '0xb', '0xc', '0xd', '0xe', '0xf', '0x10', '0x11', '0x12', '0x13', '0x14', '0x15', '0x16', '0x17', '0x18', '0x19', '0x1a', '0x1b', '0x1c', '0x1d', '0x1e', '0x1f', '0x20', '0x21', '0x22', '0x23', '0x24', '0x25', '0x26', '0x27', '0x28', '0x29', '0x2a', '0xa7', '0x2c', '0x2d', '0x2e', '0x2f', '0x30', '0x31', '0x32', '0x33', '0x34', '0x35', '0x36', '0x37', '0x38', '0x39', '0x3a', '0x3b', '0x3c', '0x3d', '0x3e', '0x3f', '0x40', '0x41', '0x42', '0x43', '0x44', '0x45', '0x46', '0x47', '0x48', '0x49', '0x4a', '0x4b', '0x4c', '0x4d', '0x4e', '0x4f', '0x50', '0x51', '0x52', '0x53', '0x54', '0x55', '0x56', '0x57', '0x58', '0x59', '0xae', '0x5b', '0x5c', '0x5d', '0x5e', '0x5f', '0x60', '0x61', '0x62', '0x63', '0x64', '0x65', '0x66', '0x67', '0x68', '0x69', '0x6a', '0x6b', '0x6c', '0x6d', '0x6e', '0x6f', '0x70', '0x71', '0x72', '0x73', '0x74', '0x75', '0x76', '0x77', '0x78', '0x79', '0x7a', '0x7b', '0x7c', '0x7d', '0x7e', '0x7f', '0x80', '0x81', '0x90', '0x83', '0x84', '0x85', '0x86', '0x87', '0x88', '0x89', '0x8a', '0x8b', '0x8c', '0x8d', '0x8e', '0x8f', '0x82', '0x91', '0x92', '0x93', '0x94', '0x95', '0x96', '0x97', '0x98', '0x99', '0x9a', '0x9b', '0x9c', '0x9d', '0x9e', '0x9f', '0xa0', '0xa1', '0xa2', '0xb4', '0xa4', '0xa5', '0xa6', '0x2b', '0xa8', '0xa9', '0xaa', '0xab', '0xac', '0xad', '0x5a', '0xaf', '0xb0', '0xb1', '0xb2', '0xb3', '0xa3', '0xb5', '0xb6', '0xb7', '0xb8', '0xb9', '0xba', '0xbb', '0xbc', '0xbd', '0xbe', '0xbf', '0xc0', '0xc1', '0xc2', '0xc3', '0xc4', '0xc5', '0xc6', '0xc7', '0xc8', '0xc9', '0xca', '0xcb', '0xcc', '0xcd', '0xce', '0xcf', '0xd0', '0xd1', '0xd2', '0xd3', '0xd4', '0xd5', '0xd6', '0xd7', '0xd8', '0xd9', '0xda', '0xdb', '0xdc', '0xdd', '0xde', '0xdf', '0xe0', '0xe1', '0xe2', '0xe3', '0xe4', '0xe5', '0xe6', '0xe7', '0xe8', '0xe9', '0xea', '0xeb', '0xec', '0xed', '0xee', '0xef', '0xf0', '0xf1', '0xf2', '0xf3', '0xf4', '0xf5', '0xf6', '0xf7', '0xf8', '0xf9', '0xfa', '0xfb', '0xfc', '0xfd', '0xfe', '0xff']
    # b = [int(i[2:], 16) for i in b]
    # for i,v in enumerate(a):
    #     if v != b[i]:
    #         print(hex(i), hex(v), hex(b[i]))
    #         input()
    #
    #

    main()
    flag = ''.join(['D', 'H', '{', 'G', 'o', '!', 'G', '0', '!', 'G', 'O', '!', '_', 'a', 'd', 'd', '_', 'f', '4', 's', 't', '3', 'r', '~', '_', '4', 'n', 'd', '_', 'x', '0', 'r', '_', 'f', '4', 's', 't', '3', 'R', '_', 'd', '1', 'v', 'i', 'd', '3', '_', 't', 'h', '3', '_', 'Q', 'u', 'E', 'r', 'y', '!', '!', '!', '}'] )
    print(flag)
    # flag: DH{Go!G0!GO!_add_f4st3r~_4nd_x0r_f4st3R_d1vid3_th3_QuEry!!!} 
    # flag:




# 0x47
# 0xa3 0xa8
# 0x376 0x871
# 0x90 0x57 
#
# 0xae
# 0xa8 0xb4
# 0x871 0x871
# 0x57 0x57 
